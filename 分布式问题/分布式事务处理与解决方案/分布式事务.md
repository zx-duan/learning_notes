## 什么是事务

![1572400754866](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572400754866.png)





## 为什么有分布式事务的问题

由于微服务开发 , 每一个服务在一个服务器中 , 所以当多个服务联合操作的时候总会造成一方错误其余方没有回滚或者当前业务正常执行而调用方发生异常导致的数据不一致



## 如何解决分布式事务问题

三种解决分布式事务的方式

1.**基于MQ可靠消息实现数据一致性**

2.**开源的框架TCC-transaction **  集成dubbo

3.**开源框架LCN** 集成springCloud





**Cap定理**

对于共享数据系统 , 最多只能同时拥有CAP其中的两个 , 没法三者兼顾

- 任两者的组合都有适用的场景

- 不同类型的业务可以也应当区别对待

  ![1572400681458](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572400681458.png)

一致性 :最终数据要是一致的 , 但不是实时一致

可用性 : 在服务器或者数据的服务端突然挂掉数据也是可用的









![1572400893228](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572400893228.png)



## 基于MQ实现的数据最终一致性

MQ如果保证一定能发出消息 , 并接受消息就称为MQ的消息可靠性 

![1572402260134](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572402260134.png)

![1572401977114](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572401977114.png)



MQ消息的投递共有六个步骤

​	![1572403626494](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572403626494.png)







![1572402149593](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572402149593.png)

如何保证消息一定能通知到消费者呢? 

如果能保证消息一定到另一边并且保证一定能收到响应就可以保证这个



==MQ在给消费者发送消息的时候 , 只需要保证消费者实现幂等性就可以保证消息一定送到并且不会重复执行== , 

解决生产者消息一定能发送到中间件的问题 

方案一

图例

![1572404755100](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572404755100.png)

1. 如果消息在发送中间件失败的时候就可以使用==消息恢复系统重新发送消息==

2. 如果中间件无法推送消息只需要实现==消费者的幂等性就可以解决了==
3. 如果没有成功调用接口无法删除保存的消息 , 只需要让消息恢复系统重新发送一次消息就可以了



缺点: 都需要访问接口 , 并且在业务数据库存消息对性能压力比较大



方案二

![1572405962685](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572405962685.png)

1. 消息发送失败就执行生产者的回滚

3. 如果消息在mq中发送失败 , 就利用消息状态确认系统确认数据库里面消息是否有成功发送,如果没有就继续发送
4. 如果消息推送失败就利用消息恢复子系统调用接口将消息数据库中的消息查询并重新推送
5. 确认失败只需要在消费者方实现幂等性就可以了

> 步骤
>
> 1.预发送消息
>
> 将生产者生产的消息通过<font style="color:red">同步</font>远程调用<font style="color:red">(消息服务系统)</font>的方式 , 发送给消息服务系统 , 消息服务系统保存这条待确认的消息 , 然后响应给生产者
>
> **如果发送了消息之后没有响应给生产者则此时会产生一个垃圾消息数据 , 我们可以通过<font style="color:red">消息状态确认的系统</font>去检查那些长时间没有被确认的消息 , 然后去业务数据库查询这个业务是否有执行成功 , 如果执行成功就调用消息服务中的消息确认超时接口将这个消息的状态修改为已确认 , 如果发现业务没有执行成功就调用删除消息的接口去删除这个消息**

> 
>
> 2.执行生产者本身的业务操作 , 将==业务的操作结果==以异步的方式发送给消息服务系统 , 然后修改消息数据库中消息的状态
>
> **如果业务的操作结果没有通知到消息服务系统的话就通过<font style="color:red">消息状态系统来检查长时间未确认的消息 , 然后查询业务的执行结果 , 判断是否更新消息的状态</font>**



> 3.将已经确认的消息发送到MQ上面去 
>
> **如果在发送MQ的过程中消息发送失败而业务均已执行完毕 , 此时可以通过消息恢复系统来检查消息数据库中长时间的<font style="color:red">已经确认但是没有删除的消息</font>然后通过消息恢复系统重新的往MQ里面发送消息**



> 4.消息的消费者通过幂等性或者ack机制来确保消息能够正常的消费 , 如果消息正常消费完毕 , 则通过调用<font style="color:red">消息服务</font>的接口删除掉这个已经确认的消息











## 使用TCC框架来发送消息

![1572406215154](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572406215154.png)

![1572406226259](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572406226259.png)

源码示例图

![1572406260605](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572406260605.png)



## LCN分布式事务处理

![1572406628436](C:\Users\Zhangxinuser\AppData\Roaming\Typora\typora-user-images\1572406628436.png)

缺点 :一方执行错误需要等待的时间长





## Spring事务的隔离级别

在提问Spring事务的隔离级别的时候 , 我们需要先知道有什么问题我们需要使用这些隔离

<font style="color:red">脏读</font>

​	一个事务读到另一个事务未提交的更新数据，所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–>取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读



<font style="color:red">幻读</font>

​	是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。



<font style="color:red">不可重复读</font>	

​	在一个事务里面的操作中发现了未被操作的数据 比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读



| DEFAULT            | **使用数据库本身使用的隔离级别**                             |
| ------------------ | ------------------------------------------------------------ |
| ORACLE（读已提交） | MySQL（可重复读）                                            |
| READ_UNCOMITTED    | 读未提交（脏读）最低的隔离级别，一切皆有可能。               |
| READ_COMMITED      | 读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。     |
| REPEATABLE_READ    | 可重复读，解决不可重复读的隔离级别，但还是有幻读风险。       |
| SERLALIZABLE       | 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 |

​                                                                                                                                                                                                                                                                                                            