<h1>在分布式集群的项目开发中由于分布式结构跨服务的特点我们将分布式项目的单一服务抽取出来交给Tomcat来管理甚至多个Tomcat来管理 , 由于不同的服务差异 ,彼此之间为了达到分布式的效果与代码的降低耦合的特点 会遇到大大小小的问题 ,这里将说明一下遇到了哪些问题与设计并解决这些问题的思路</h1>
## 业务逻辑层





#### 一.区分异常与自定义异常问题

**在项目的实际开发中 , 业务逻辑异常与系统异常的区分**

用到的知识点  **统一异常处理** , **自定义异常** ,**AOP**  *`相关技术的实现请看分布式集群/异常处理方案`*

在项目的实际开发中有一些异常是用户操作的逻辑异常 **(例: 用户手机号格式不对,用户账户或密码错误...)**但是有些异常是我们程序或维护时候产生的异常 , 不同的异常对于用户应该呈现不同的效果 ,如果将系统的异常直接抛给用户 ,这样对于用户的体验是极差的因为用户看不懂我们的异常, 所以我们要用`统一异常处理的方式`来处理我们系统的异常 , 提示给用户一个友好的信息,但是这样做的后果就是 , 业务逻辑异常我们没办法达到想要的效果,在程序的设计角度 ,我们可以自定义我们想要给用户看到的异常,当用户是业务逻辑异常的时候我们给用户展示自定义异常 , 当我们系统出现了问题 , 就在自定义异常中 , 给用户展示系统的异常 , 这样对用户的体验也是比较好的





#### 二. 获取同一个对象代码冗余问题

**用户对象注入**

用到的知识点 **Spring参数解析器** , **SpringBoot的注入**

`相关技术Spring/spring组件/参数解析器 `,`SpringBoot/SpringBoot常用配置/Bean对象注入篇`

> 相关代码实现请看分布式集群 / 代码实现与业务介绍 用户对象注入篇

虽然拦截器与Cookie等都能够实现我们在控制器上面获取这个对象的数据 , 不过相对而言的代价就是如果有很多个控制器 , 那么获取用户对象的这部操作就要写很多个 , 随着业务功能的增加 产生了一些不必要的重复代码 , 我们可以通过Spring参数解析器的参数封装原理在其扫描参数解析器的同时由参数解析器获取我们的这个对象 , 从而达到获取这个用户对象的目的 , 其操作的大概实现逻辑就是 , 我们创建一个参数解析器 , 通过循环参数解析器来判断是否等于我们想要的数据的类型 , 如果等于我们要的数据的类型就在下面执行的方法中获取我们想要的数据*`相关原理与代码设计请看参数解析器篇`*

**解决的问题**

解决了多个controller互相之间获取同一个对象重复代码的问题





#### 三.VO对象的使用

用到的知识点 **对象的转化**

相关技术请看 `分布式集群/代码设计`

> 设计的实现可以看分布式集群 /代码设计 VO篇

在很多时候 , 尤其是在使用**Redis / MongoDB / ES**这种非关系型数据库的时候 , 没有办法找到一个合适的java类来对数据的查询 , 增删改 进行封装 , 如果要使用别的服务中的Domain来封装却又不太符合我们的设计规范 , 所以我们将 需要操作的或者和真实对象类似的属性类封装成一个**VO对象** , 用来处理我们非关系型数据库绑定的问题 , 设计的大致思路就是 , 不同对象也有可能有共同的属性 , 我们将这些属性单独抽取出来操作会方便我们的书写  , 等进行入库 , 初始化操作的时候 ,可以通过对象Cpoy这个方法进行两个不同对象之间属性的重叠



## 服务器层

#### 一.分布式中Session无法的共享问题

用到的知识点 **Cookie** , **分布式集群的结构** ,**redis** 

`相关技术的实现请看分布式集群的结构 , javaweb学习总结Cookie`,`数据库/Redis/Redis的使用方法`

> 实现的方法
>
> 1.Nginx的同IP负载均衡策略 : 用同一个ip去固定的一个服务器  (不优雅 , 存在隐患)
>
> 2.tomcat的session共享使用tomcat的广播机制发送到别的tomcat的服务器上 (不优雅 , 万一不广播怎么办)
>
> 3.<font style="color:red">redis + cookie</font>(实现的理念就是 我们的程序我们控制 , 不交给第三方来控制)

在传统的开发过程中 , 我们可以将我们服务器与浏览器乃至后台共享的数据存放到Session中 , 不过在分布式集群的今天 , 由于服务器集群的概念 , 每个服务器之间的Session是不共存的这样我们 请求A服务器保存起来的Session数据 ,等第二次请求的时候被负载均衡分配到了不同的服务器上面 , 我们在B服务器没有办法获取到A服务器的Session因为Session的存储是存在服务器上面的 , 但是由于Cookie是保存在用户的浏览器上面 , 而且Session的底层也是由Cookie实现的 *`详情看javaweb学习总结 cookie篇`*所以我们可以将用户的数据每次在请求服务器之后保存在用户的Cookie中 , 虽然实现了我们的要求 , 但是及其不安全 , 因为用户可能会对Cookie进行修改 , 导致我们携带的Cooike是有问题的 , 所以我们进一步进行`加密处理` , 我们可以让Cookie当做一个==令牌==, 然后在用户进行操作的时候用让用户携带这个令牌进入我们的服务器 , 我们通过这个令牌去我们的 数据库也好 , 缓存中也好 去获取这个数据(用户) , 并共享到我们的当前服务器的Session中达到共享Session的目的 

**解决的问题**

可以解决分布式开发登录的问题

**诞生的问题** : 用户禁用cookie , ~~cookie与redis消失的问题~~





#### 二. Cookie的存活时间 , 与Redis的存活时间

用到的知识点 **拦截器** , **Cooike** , **Redis** 

`相关技术Spring/spring组件/拦截器 javaweb学习总结/Cookie ;数据库/Redis`

> 相关实现请看分布式集群 / 代码实现与业务介绍 Cookie Redis过期策略篇

通过Cookie携带令牌的策略虽然可以做到共享Session. 但是随着而来的问题也出现了 , 在用户实际使用的时候由于我们获取令牌 , 获取数据 , 存放Session都是在单一的控制器中完成的 , 这样带来的后果就是 , 用户即使正在操作但随着我们对 Redis与Cookie设置了存活时间 *`(业务所需因为通常情况下用户在一定时间不操作的时候是要将Cookie与Redis中缓存的数据做销毁处理)`* 用户即使在访问的时候也会随着Cookie的过期 Redis缓存数据的过期 从而重新登录,这样对用户的体验是非常不好的  , 但是即使我们在用户每一次需要账户的地方重新设置Cookie 的存活时间 与Redis的存活时间 , 如果用户不进行需要账户的业务处理*`(比如搜索商品 , 搜索旅游攻略)`*那么我们对Cookie 与 Redis的设置就一点意义都没有 , 所以我们换一个角度 , 如果用户每一次的请求或者访问的时候都重新重置一下Cookie或者Redis的过期时间 不就可以达到我们想要的效果了么 , 通过这种思想 , 我们找到可以解决办法的方式有<font style="color:red">过滤器 , 拦截器 , 控制器</font>  , 在这里我们使用 `拦截器` 来处理 , *`(为什么这样 , 详情请查看WEB学习 / 拦截器过滤应用选择场景篇)`*由于拦截器的特性 , 会对每一次的请求做拦截处理 , 所以我们可以在拦截器中获取令牌 , 然后在拦截器通过该令牌获取Redis中存储的对象 , 并在每一次获取的同时 **延长Cookie与Redis缓存中数据的时间**从而达到我们想要的效果 , 让用户在进行操作的时候不会因为时间过期而重新登录

**解决的问题**

用户操作的时候cookie的过期与redis过期





## 数据库层

#### Redis数据库优雅存储的问题

用到的知识点     **枚举** , **成员静态常量**  `相关技术:java常用功能文件下的枚举`

我们知道Redis存储是以 key  value的形式来进行存储 , 但是我们程序员在存储的时候==key要见名知意==,并且还要符合规范 , 我们把Key可以抽取成一个成员静态常量 , 不过这样带来的问题就是也许不同的员工在开发的时候都是用的一个名字的静态常量, 容易造成Key重复的问题 , 一旦key重复 ,我们Redis存储的数据就会被覆盖 , 这样对设计是有缺陷的 , 为了解决这一缺陷 ,我们利用java 枚举的特点 , 在java枚举中由于枚举的特点 `即: 规定了类型就不可以更改的这一特点 ,如果修改必须修改源代码`我们可以将我们固定的key的格式抽取成枚举 , 如果想要在枚举中设置别的属性或字段自动加即可 `如果不懂枚举的格式详情去看`<font style="color:red">java常用功能文件下的枚举即可</font>这样可以尽量的避免我们不同的人员在开发时存储key重复的问题







#### Redis的数据持久化 / 数据初始化的

用到的只是点 **监听器** , **定时器** , **redis**  `相关技术: spring / 组件 /(定时器/监听器)`

**初始化** : 在Redis中虽然可以根据业务逻辑 进行判断当前缓存是否存在用户需要的信息 , 如果不存在查询数据库在添加的这种操作 , 但是毕竟要执行两部分 , 感觉很麻烦 , 我们可以极致的优化我们的代码 , 设想一开始如果我就有这些数据不就好了么 , 所以我们数据初始化的概念就出现了 , 满足初始化的这个概念需要以下条件: <u>执行一次就可以 , 不要做多余的操作</u> 所以经过筛选最优良的解决办法就是使用我们的<font style="color:red">监听器</font>, ==在监听器中监听SpringBoot的容器声明周期 , 在初始化我们的Spring容器的时候就往Redis中加载我们的数据 , 从而达到我们的目的==

**持久化** : 在操作了Redis进行数据缓存处理的时候 , 由于Redis中的数据始终存在缓存中, 这样数据就有可能造成丢失的问题 , 为了防止数据的丢失 , 我们需要将数据 序列化到我们的磁盘中 , 这样才能保证数据最大的正确率 , 不过这样做随之而来就带来了一个问题 , 我们该什么时候持久化这些数据 , 以及用什么方式才可以更好的处理我们的数据 , 用来持久化 **解决办法之一** : ==用定时器来帮助我们解决这个问题==  , 因为定时器满足了我们 , 什么时候持久化 or 用什么组件持久化才最好的两个因素 , 而且使用了定时器后 , 我们只需要配置好时间就可以让程序自动的按照指令来进行数据持久化了







#### 二.如何优雅的提升数据库的查询性能 , 并且基于分布式的理念达到处理高并发 , 高请求的问题 

用到的知识点   **redis** , **mongoDB** , **Es**  <font style="color:red">`相关技术:数据库Redis MongoDB 分布式集群的结构等..` </font>

在传统(旧时代)的项目开发中一个Tomcat就可以处理一个应用程序 , 因为那个时候用户的访问量不多 , 业务也没有那么复杂 , 单一的程序结构可以完成相对应的要求 , 在互联网用户日益剧增的今天 , 很明显这种结构完全不足以支撑程序对于访问数量的处理 , 甚至前后端分离 , 分布式都不一定能够处理我们如今大数据时代的并发与请求 , 不过在分布式集群的今天 , 由于服务器框架的**负载均衡**策略 , 用户大量的请求都被分发到不同的服务器上面 , 但是数据库就只有一个 , 最终的请求都是会访问数据库的 , 这样数据库用不了多久就会宕机 , 所以我们将数据库也做了集群处理 并且<font style="color:red">在数据库与服务器之间</font>建立一片`缓存区域`用以优雅的存储数据进行数据的操作并降低数据库的压力 , 提升程序的性能 , 其中以Redis , mongoDB比较出色 , 设计的思路与理念就是 , 在我们做数据库数据访问的时候 , 我们将一些<font style="color:red">`冷数据`</font>,<font style="color:red">还有一些次要的非实时性的数据</font>, 保存到缓存中 , 当用户再次访问的时候 , 我们没有必要再从数据库里面查询 , 而是直接从缓存中查询 , 这样用户的体验好, 也能节省我们的数据库性能 , 不过值得注意的是 , 由于现在是分布式集群 , 不同的服务之间没有特别的共通的地方 , 也就是说我们有可能再 A服务做DML操作 , 在B服务做DQL操作同一个业务 , 这样就会造成数据的不及时更新 , 解决的办法就是将已经分离的主从数据库 做主从同步 ,这个后续再说

==冷数据==: 修改不频繁的数据  条件查询远大于修改

==热数据==: 修改的频率比较高  数据频繁的改动











