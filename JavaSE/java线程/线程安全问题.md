# 线程安全问题





### 什么是线程安全问题? 

线程安全其实就是数据共享问题 , 如果在某一个类中定义了一个成员变量 , 当该类可以多线程访问的时候 , 多个线程共享同一份数据 , 那么该数据就存在==线程安全问题== 





### 高并发的情况下保证线程安全是怎么做?

java多线程并发编程需要保证线程安全的三个要素 

1.原子性

2.有序性

3.可见性

当然由于==synchronized==和==Lock==保证每个时刻只有一个线程执行同步代码, 所以线程是安全的 , **但是由于线程是同步执行的, 所以会影响效率**



**原子性 : **表示一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断 , 要么就都不执行

在JAVA中**基本数据类型的变量的读取和赋值操作**是原子性操作 , 即这些操作是不可以被中断的 , 要么执行 , 要么不执行



**可见性 :** 指当多个线程访问同一个变量的时候 , 一个线程修改了这个变量的值, 其他的线程能够立即看到修改的值当一个共享变量被 volatile 修饰时 , 它会保证修改的值立即被更新到主存 , 更新后将其他线程的缓存行更新为新的主存地址

当其他线程读取变量的时候发现自己的缓存行无效 , 它会等待缓存行对应的主存地址被更新之后 , 然后去对应的主存读取最新的值

普通的共享变量不能保证可见性, 因为普通共享变量被修改后 , 什么时候被写入主存是不确定的 ,当其他的线程去读取时候 , 此时内存中还是原来的旧值 , 因此无法保证可见性



更新主存的步骤 : 当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效 , 然后当前线程将变量的值更新到主存 , 更新成功后将其他线程的缓存更新为新的主存地址



其他线程读取变量时 , 发现自己的缓存行无效 , 它会等待缓存行对应的主存地址被更新之后 , 然后去对应的主存读取最新的值



**有序性 :** 即程序执行的顺序按照代码的先后顺序执行



在java内存模型中 ,允许编译器和处理器对指令进行重排序 , 但是重排序过程不会影响到单线程程序的执行 , 却会影响到多线程并发执行的正确性



可以使用volatile关键字来保证一定的 "有序性"



![img](https://img-blog.csdn.net/20180507151857964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pY2hhZWxlaG9tZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



当在处理并发编程的时候 , 只要程序满足了原子性 , 可见性和有序性 , 那么程序就不会发生脏数据的问题



### 死锁

 [原文](https://blog.csdn.net/wljliujuan/article/details/79614019)

产生死锁的四个必要条件

1.互斥

2.不可剥夺

3.请求与保持条件

4.循环等待条件

