# 什么是微服务

微服务就是面向服务开发 , 将不同模块的功能架构全都拆分出来转而项目结构变成微服务开发

将服务拆分 , 用的多的服务放到性能高的服务器 , 不高的放到性能低的服务器
面向微服务开发



# 为什么要用微服务

> 互联网项目访问比较大,为了保证访问的可靠性 .. 就使用了微服务架构
>
> B/S软件架构的出现标志着web开发时代的到来，当初应用都是比较简单，功能单一，访问量少。这些因素就决定了
> 当年的应用结构是比较简单的
>
> ![1567860797594](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860797594.png)
>
> 随着家用电脑的普及，互联网的兴起，上网的人越来越多，逐渐显得简单的架构无法支撑应用程序的正常运行，软件科学家们就开始探讨如何去设计软件的架构，最初比较突出的两大问题在于1台服务器无法保证应用程序和数据库程序两个老虎的性能，科学家就提出把应用程序和数据库程序分别安装在2台服务器中，通过网络来进行数据传输，再通过应用程序中加本地缓存的方式来解决不常变动数据的查询性能问题，此时出现了最早期的分布式系统架构
>
> ![1567860820144](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860820144.png)
>
> 伴随着大数据时代的到来，这种简单是分布式系统架构也开始扛不住了，服务器宕机，成了常见的事情，科学家又开始探索，如何提高系统的稳定性和可用性，于是提出了，应用服务集群和数据库服务器集群，通过负载均衡的方式来维持系统的高可用和稳定性，以应对这个时代的高并发
>
> ![1567860834332](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860834332.png)
>
> 在某些业务中，关系型数据库明显不适合，如：点赞，评论，全文检索等。这些业务场景使用关系型数据库来完成会严重的影响数据库的性能，科学家们又拓展出非关系型数据库（NoSQL），用于项目中的某个特殊的业务场景，去弥补关系型数据的短板，此时这样的系统架构基本满足当前时代下的需求
>
> ![1567860864121](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860864121.png)
>
> JavaEE应用三层架构，取得巨大成功后，在很长的一段时间内，都没有出现过问题，直到大数据时代的到来某些数据量巨大的公司开始遇到了新的挑战。某些业务方法频繁调用，需要配置大量的资源，某些业务方法很少调用，只需配置少量资源，如：商城应用中的服务
>
> ![1567860910664](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860910664.png)
>
> 在商城的应用中，订单服务，积分服务，商品服务的使用频率远远大于其他服务，如果仅仅通过布置多台服务器的方式来缓解压力的造成的问题，此时会造成服务器成本的大量提升，并且资源得不到充分的利用，造成浪费，遇到某个关系型数据库不好处理的业务场景，在技术选择的时候也要充分去考虑系统稳定和冲突问题，于是科学家们又探索出基于服务的分布式应用架构，服务拆分越细，数量就越多，这种应用架构就是当下最热门的微服务应用架构。目前比较成熟，社区活跃的微服务框架有Dubbo，SpringCloud
>
> ![1567860943447](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567860943447.png)



# **微服务的新概念**

## **生产者**

提供业务逻辑实现的角色 , 对外提供服务

## **消费者**

调用生产者提供的服务使用其业务功能

## **负载均衡**

服务器之间的算法将服务器的请求分配给不同服务器 , 目前硬件的负载均衡最牛的是华为的

## **读写分离服务器**

主从同步: 将更新后的数据同步到从服务器

## **RPC连接协议**

一种访问数据的连接协议 , RPC连接可以可以通过外部访问不同服务器中的内容 即两个服务器之间互相通讯访问

底层的原理就是使用序列化与反序列化

1. 序列化:将java对象转换为二进制数据

2. 反序列化 : 把二进制数据转换为java对象

   要实现序列化 需要在java对象上面实现`Serializable`接口

   ![1567861479141](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567861479141.png)

   

## **控制中心**

控制中心的概念就像一个公众平台 , 当生产者生产出数据之后 , 会通知和提交到控制中心中, 然后控制中心就会通过通知的方式来通知消费者 , 消费者通过订阅来从控制中心获取数据的最新信息(生产者生产的数据名,生产者生产数据的端口号),消费者此时可以通过控制中心提供的信息来对生产者进行数据访问

> 生产者在初始化开启后会向注册中心注册(register),然后注册中心会通知(notify)消费者 , 消费者通过订阅(subscribe)注册中心来获取生产者已经更新最新生产的数据然后将发布的服务存放在本地的缓存之中,当消费者需要调用服务的时候,此时消费者会通过RPC协议(也就是序列化和反序列化)来从生产者调用相关的服务,最终会将记录发布到监控中心去(旧)

注册中心的作用是通知订阅了的消费者,生产者已经做出了更新 , 没有注册中心也是可以的 , 只是消费者
无法再及时的获取生产者所更新的数据

常用的注册中心有两个有**zookeeper**，**eruka**



## **监控中心**

监控中心的作用是监控消费者和生产者之间的执行记录,**方便运维人员优化和监控**





# **微服务能做什么 , 有什么好处**

- 降低系统的耦合度

- 服务器之间都是相互独立，互补干扰，此时每个服务都能更好的选择符合业务场景的技术

- 充分使用服务器的硬件资源，避免造成不必要的浪费

- 降低维护成本和难度

- 提高应用系统的稳定性

- 微服务还有一个优势 , 对技术的组合更自由, 不用考虑冲突互相调用需要使用RPC远程协议在不同的服务和服务之间也可以通过RPC协议访问结果

  

# **微服务的缺点**

做成微服务的项目 , 在处理事务上面比较麻烦 , 因为微服务是将服务分布在不同的服务器上面 ,所以旧版处理事务的方式对于微服务的项目是无效的 , 需要采用新的微服务事务处理的方式

1.微服务架构可能带来过多的操作。

2.需要DevOps技巧 (http://en.wikipedia.org/wiki/DevOps)。

3.可能双倍的努力。

4.分布式系统可能复杂难以管理。

5.因为分布部署跟踪问题难。

6.当服务数量增加，管理复杂性增加。







# **分布式与微服务的区别**

> 分散部署是分布式 , 而微服务就是将一个应用的内部服务进行拆分就是微服务
> 微服务是基于RPC远程协议的
>
> 微服务是分布式的表现形式之一 , 微服务一定是分布式 , 分布式不一定是微服务









# **如何实现微服务的项目 ?** 

由于项目的结构的变化 , 我们需要一个服务对应一个服务器 , 来解决服务器的压力与并发的问题

结构示意图:

![1567857415795](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567857415795.png)

## **创建步骤**

1. 创建好生产者需要的API  

   API用于约定和规范生产者生产什么样什么类型的数据

   内部结构是

    <font style="color:red">`domian`实体类</font> 用于提供生产者数据封装的类型

   <font style="color:red">`service`接口</font> 用于规定生产者使用什么方法

   该规范是提供给生产者来使用的 , 所以要打包成jar包

2. 创建生产者 , 生产者用于提供给消费者数据 , 生产者需要用服务器跑起来

   内部结构是

   <font style="color:red">`serivceImpl`</font>接口实现类 用于实现接口的方法给消费者

   `mapper` 数据访问接口 用于获取真实数据

   由于生产者调用了api规范 , 所以要引入api的jar包 

3. 创建消费者 , 消费者用于消费生产者提供的数据 , 只要谁引用谁 , 那么该类就是被引用的类的消费者

   `controller` 用于访问生产者生产的数据 采用 RPC 协议来进行访问

   > 从以上图中我们不难看出，我们至少需要创建5个项目
   > product-api：定义商品相关的业务方法
   > member-api：定义会员相关的业务方法
   > product-sever：商品服务的提供者，同时也是会员服务的消费者，底层会去调用会员服务的相关功能
   > member-sever：会员服务的提供者，提供会员业务方法的实现
   > website：商品服务的消费者，使用商品服务提供的业务功能







# **注意事项**

负载均衡

> 负载均衡的分配方式
>
> 轮询 , 从头到尾从尾到头
>
> hash , 根据第一次访问判断(ip一致)
>
> 最少活跃的服务器被分配 , 



