1、为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；

2、Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；

3、Redis的高级功能：包括持久化、复制、哨兵、集群介绍；

4、理解Redis：理解内存、阻塞，这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分；

5、开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。



**==Redies仅用于做缓存操作==**

> 要时刻记得数据有可能会丢失







## Redis不能干什么事儿

Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍，如果滥用可能导致系统的不稳定、成本增高等问题。

1.比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。

2.简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。





## 使用Redis给我们带来了什么好处

从内存中读取数据 ,大大的提高了程序的性能 , 降低数据库的压力 , 还可以使用Redis做一个





## Redis的选择

上面说了Redis的一些使用场景，那么这些场景的解决方案也有很多其它选择，==比如缓存可以用Memcache，==Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？

速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；

**注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理。**

丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20181119213123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70)



除了提供的丰富的数据类型，Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。

Redis的代码开源在GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。

![img](https://img-blog.csdnimg.cn/20181119213141787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70)







## Redies的持久化

redis持久化有两种方式：RDB和AOF

1、RDB文件是一个经过压缩的二进制文件

2、AOF文件保存redis服务器所执行的写命令来记录数据库状态

redis在服务器启动的时候会检查是否开启了AOF，如果开启了就优先使用AOF文件来缓存数据库，只有AOF关闭的时候才会使用RDB文件来还原数据库状态，AOF文件的更新频率一般比RDB文件更新的频率更高。具体流程如下：

![1567693299729](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567693299729.png)

redis中SAVE 和BGSAVE 命令可以用于生成RDB文件

1、SAVE  会堵塞服务器进程，期间服务器不能处理任何命令

2、BGSAVE 会派生出一个子进程，然后由子进程负责创建RDB，服务器进程（父进程）继续处理请求

如果在redis服务器中配置了save选项时。会让服务器每个一段时间执行一次BGSAVE。

例如

save 900 1

save 300 10

save 60 10000

那么只要 900秒数修改一次，300秒修改10次，60秒修改10000次其中一个条件，系统就会执行BGSAVE命令。

AOF打开时，每次执行写命令都会追加到服务器的aof_buf缓冲区末尾，而什么时候写入aof文件则取决于appendfsync 参数的配置。appendfsync 参数的配置会直接影响持久化的效率和安全性。

1、always 每个事件循环都将aof_buf

中的数据写入 aof文件，并同步aof文件，所以always 执行

2、everysec 每个事件循环写入aof，并且每秒同步aof文件

3、no 表示每个事件循环都写入aof，但是何时同步aof文件，则由系统决定。

综上所述：

效率：always  

安全性：always  >everysec  >no

写入aof和同步aof的理解：

操作系统为例提高写入效率，当用户调用write方法时，会先写入内存缓冲区，当缓冲区空间被填满，或者超过指定时限时才会写入硬盘。但是在计算机停机的时候，这部分数据将会丢失。为此，系统提供了fsync,fdatasync两个方法，强制将缓冲区的内容写入硬盘。所以写入aof只是写入到内存缓冲区，而同步aof才最终写入硬盘实现数据的持久化。

aof记录所有的写命令，aof文件内容越来越多，体积越来越大，可能会影响redis的性能，同时会存在很多冗余的命令。为了解决这个问题，redis实现了一个AOF重写的功能。

AOF 重写实际上是读取数据库中的键值，生成一个新的AOF文件。生成新的AOF文件的时候线程将会长时间堵塞，影响线上操作，所以redis实现了 bgrewriteaof 。即在aof重写期间，客户端发送来的写命令redis会写入一份到 aof重写缓冲区（并非aof缓冲区，实际上会同时向aof缓冲区和aof重写缓冲区各写一份）中，完成创建写aof文件之后，会将aof重写缓冲区中的内容追加到新的aof文件中

## Redis的缓存

![1567693726905](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567693726905.png)

![1567693764534](C:\Users\Zhangxinuser\Desktop\新的学习总结\imgs\1567693764534.png)



### 缓存雪崩

我们都知道Redis不可能把所有的数据都缓存起来**(内存昂贵且有限)**，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。Redis对过期键的策略+持久化

如果缓存数据**设置的过期时间是相同的**，并且Redis恰好将这部分数据全部删光了，这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。

**这就是缓存雪崩：**

- Redis挂掉了，请求全部走数据库；
- 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。

缓存雪崩如果发生了，很可能就把我们的数据库**搞垮**，导致整个服务瘫痪！



**如何解决缓存雪崩？**

对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：

**解决方法**：在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期。**

对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：

- **事发前**：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
- **事发中**：万一Redis真的挂了，我们可以设置**本地缓存(ehcache)+限流(hystrix)**，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
- **事发后**：redis持久化，重启后自动从磁盘上加载数据，**快速恢复缓存数据**。

